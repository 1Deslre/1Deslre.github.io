<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java面试题2</title>
    <link href="/2024/02/17/Java%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <url>/2024/02/17/Java%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="实现一个函数式接口有哪几种方法？"><a href="#实现一个函数式接口有哪几种方法？" class="headerlink" title="实现一个函数式接口有哪几种方法？"></a>实现一个函数式接口有哪几种方法？</h3><p>三种方式：</p><p>​1.通过一个类来实现，包括常规的类和匿名内部类</p><p>​2.通过lambda表达式来实现</p><p>​3.通过方法引用来实现</p><h3 id="List-和-Map、Set-的实现类"><a href="#List-和-Map、Set-的实现类" class="headerlink" title="List 和 Map、Set 的实现类"></a>List 和 Map、Set 的实现类</h3><p>​List 有序, 可重复 ArrayList 优点: 底层数据结构是数组，查询快，增删慢。 13 缺点: 线程不安全，效率高 Vector 优点: 底层数据结构是数组，查询快，增删慢。 缺点: 线程安全，效率低, 已给舍弃了 LinkedList 优点: 底层数据结构是链表，查询慢，增删快。 缺点: 线程不安全，效率高 Set 无序,唯一 HashSet 底层数据结构是哈希表。(无序,唯一) 如何来保证元素唯一性? 依赖两个方法：hashCode()和 equals() LinkedHashSet 底层数据结构是链表和哈希表。(FIFO 插入有序,唯一) 1.由链表保证元素有序 2.由哈希表保证元素唯一 TreeSet 底层数据结构是红黑树。(唯一，有序) 1. 如何保证元素排序的呢? 自然排序 比较器排序 2.如何保证元素唯一性的呢? 根据比较的返回值是否是 0 来决定  Map 接口有四个实现类： HashMap 基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键， 线程 不安全。 HashTable 线程安全，低效，不支持 null 值和 null 键； LinkedHashMap 线程不安全，是 HashMap 的一个子类，保存了记录的插入顺序； TreeMap 能够把它保存的记录根据键排序，默认是键值的升序排序，线程不安全</p><h3 id="Reids提供持久化有两种，那应该怎么选择呢"><a href="#Reids提供持久化有两种，那应该怎么选择呢" class="headerlink" title="Reids提供持久化有两种，那应该怎么选择呢"></a>Reids提供持久化有两种，那应该怎么选择呢</h3><ol><li><p>不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。 </p></li><li><p>也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢 复速度更快; 第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备 份和恢复机制的 bug 。 </p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制， 用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。 </p></li><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新 构建数据，因为 AOF 中的数据更加完整。</p></li></ol><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>​缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候， 先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据</p><h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以 根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： （1）定时去清理过期的缓存； （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数 据并更新缓存</p><h3 id="缓存降级-1"><a href="#缓存降级-1" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然 需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开 关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的 （如加入购物车、结算）</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题1</title>
    <link href="/2024/02/17/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/02/17/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-string-常用的方法有哪些？"><a href="#1-string-常用的方法有哪些？" class="headerlink" title="1.string 常用的方法有哪些？"></a>1.string 常用的方法有哪些？</h3><p>​indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。</p><h3 id="2-ThreadLocal-的原理"><a href="#2-ThreadLocal-的原理" class="headerlink" title="2.ThreadLocal 的原理"></a>2.ThreadLocal 的原理</h3><p>​ThreadLocal：为共享变量在每个线程中创建一个副本，每个线程都可以访问自己内部的副本变量。通过 threadlocal 保证线程的安全性。 其实在 ThreadLocal 类中有一个静态内部类 ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap 中元素的key 为当前ThreadLocal 对象，而 value 对应线程的变量副本。 ThreadLocal 本身并不存储值，它只是作为一个 key 保存到ThreadLocalMap中，但是这里要注意的是它作为一个 key 用的是弱引用，因为没有强引用链，弱引用在GC的时候可能会被回收。这样就会在 ThreadLocalMap 中存在一些key 为null 的键值对（Entry）。因为 key 变成 null 了，我们是没法访问这些 Entry 的，但是这些Entry 本身是不会被清除的。如果没有手动删除对应 key 就会导致这块内存即不会回收也无法访问，也就是内存泄漏。 使用完 ThreadLocal 之后，记得调用 remove 方法。 在不使用线程池的前提下，即使不调用 remove 方法，线程的”变量副本”也会被 gc 回收，即不会造成内存泄漏的情况。</p><h3 id="3-线程池的拒绝策略有哪些？"><a href="#3-线程池的拒绝策略有哪些？" class="headerlink" title="3.线程池的拒绝策略有哪些？"></a>3.线程池的拒绝策略有哪些？</h3><p>主要有4种拒绝策略： </p><p>​1.AbortPolicy：直接丢弃任务，抛出异常，这是默认策略 </p><p>​2.CallerRunsPolicy：只用调用者所在的线程来处理任务 </p><p>​3.DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务 </p><p>​4.DiscardPolicy：直接丢弃任务，也不抛出异常</p><h3 id="4-什么是线程安全"><a href="#4-什么是线程安全" class="headerlink" title="4.什么是线程安全"></a>4.什么是线程安全</h3><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。</p><p> 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码 在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p> （1）不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除 非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 </p><p>（2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代 价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的 类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet </p><p>（3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子 操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个 Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 </p><p>（4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h3 id="5-同步锁、死锁、乐观锁、悲观锁"><a href="#5-同步锁、死锁、乐观锁、悲观锁" class="headerlink" title="5.同步锁、死锁、乐观锁、悲观锁"></a>5.同步锁、死锁、乐观锁、悲观锁</h3><p>​同步锁： 当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 9 死锁： 何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。乐观锁： 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_conditio 机制，其实都是提供的乐观锁。在 Java 中 java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</p><h3 id="6-乐观锁和悲观锁的使用场景"><a href="#6-乐观锁和悲观锁的使用场景" class="headerlink" title="6.乐观锁和悲观锁的使用场景"></a>6.乐观锁和悲观锁的使用场景</h3><p>​乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的 场景下用悲观锁就比较合适。</p><h3 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h3><p>​死锁是一个互相争抢的过程，互相拥有对方需要的资源又不释放 39 &#x2F; 132 死锁的发生必须具备以下四个必要条件。 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求 资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞， 但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的 P0 正在等 待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 只要打破四个必要条件之一就能有效预防死锁的发生</p><h3 id="8-产生死锁的四个必要条件？"><a href="#8-产生死锁的四个必要条件？" class="headerlink" title="8.产生死锁的四个必要条件？"></a>8.产生死锁的四个必要条件？</h3><ol><li><p>互斥条件：一个资源每次只能被一个线程使用</p></li><li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放 </p></li><li><p>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺 </p></li><li><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p></li></ol><h3 id="9-如何避免死锁？"><a href="#9-如何避免死锁？" class="headerlink" title="9.如何避免死锁？"></a>9.如何避免死锁？</h3><p>指定获取锁的顺序，举例如下： </p><ol><li>比如某个线程只有获得A锁和B锁才能对某资源进行操作，在多线程条件下，如何避免死锁？ </li><li>获得锁的顺序是一定的，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可 以避免死锁！！！</li></ol><h3 id="10-synchronized-和-Lock-有什么区别？"><a href="#10-synchronized-和-Lock-有什么区别？" class="headerlink" title="10.synchronized 和 Lock 有什么区别？"></a>10.synchronized 和 Lock 有什么区别？</h3><p>​首先 synchronized 是 java 内置关键字，在 jvm 层面，Lock 是个java 类；synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁；synchronized 会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock 需在 finally 中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用 synchronized 关键字的两个线程 1 和线程 2，如果当前线程1 获得锁，线程2线程等待。如果线程 1 阻塞，线程 2 则会一直等待下去，而 Lock 锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized 的锁可重入、不可中断、非公平，而 Lock 锁可重入、可判断、可公平（两者皆可）； Lock 锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题。</p><h3 id="11-高并发下如何保证修改数据安全"><a href="#11-高并发下如何保证修改数据安全" class="headerlink" title="11.高并发下如何保证修改数据安全"></a>11.高并发下如何保证修改数据安全</h3><p>​使用 Synchronized 解决，给生成 ID 的代码加上同步代码块，成功解决问题； 作用是：同一时刻，只有一个线程可以执行该代码块 使用 Lock 锁解决问题：给生成 ID 的代码加上 Lock 锁，成功解决问题； 悲观锁—在修改数据的时候,采用锁定状态,排斥外部请求的修改,遇到加锁的状 态,就必须等待 弊端: 在高并发下,每个请求都需要等待’锁’,某些线程可能永远都没有机会抢 到这个锁,请求就会死在那里,这种请求会很多,瞬间增系统的平均响应时间,结果 时可用链接数被耗尽,系统陷入异常 FIFO 队列—-采用 FIFO(First Input First Output，先进先出),这样就不会导致 某些请求永远获取不到锁 弊端:请求很多,很有可能一瞬间将队列内存”撑爆”,系统陷入到异常状态,或者设 计一个极大的内存队列,但是系统处理完一个队列,内请求的速度根本无法和疯狂 涌入队列中的数目相比,也就是说,队列内的请求会越积累越多,最终 WEB 系统平 均响应时候还是会大幅下降，系统还是陷入异常。 乐观锁—相对于”悲观锁”采用更为宽松的加锁机制,大都是采用带版本号更新, 实现就是,这个数据所有请求都有资格去修改,但会获得一个该数据的版本号,只 有版本号符合才能更新成功,其他的返回抢购失败,这样就不用了考虑队列的问题, 31 会增大 CPU 的计算开销</p><h3 id="12-集合和数组的区别"><a href="#12-集合和数组的区别" class="headerlink" title="12.集合和数组的区别"></a>12.集合和数组的区别</h3><p>​区别：数组长度固定 集合长度可变 数组中存储的是同一种数据类型的元素，可以存储基本数据类型，也可以存储引用数据类型； 集合存储的都是对象，而且对象的数据类型可以不一致。在开发当中一般当对象较多的时候，使用集合来存储对象。</p><h3 id="13-创建线程有几种方式"><a href="#13-创建线程有几种方式" class="headerlink" title="13.创建线程有几种方式"></a>13.创建线程有几种方式</h3><p>​1.继承 Thread 类并重写 run 方法创建线程，实现简单但不可以继承其他类</p><p>​2.实现 Runnable 接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。</p><p>​3.实现 Callable 接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。</p><p>​    4.使用线程池创建（使用 java.util.concurrent.Executor 接口）</p><h3 id="14-如何启动一个新线程、调用-start-和-run-方法的区别？"><a href="#14-如何启动一个新线程、调用-start-和-run-方法的区别？" class="headerlink" title="14.如何启动一个新线程、调用 start 和 run 方法的区别？"></a>14.如何启动一个新线程、调用 start 和 run 方法的区别？</h3><p>​线程对象调用 run 方法不开启线程。仅是对象调用方法。 线程对象调用 start 开启线程，并让 jvm 调用 run 方法在开启的线程中执行调用 start 方法可以启动线程，并且使得线程进入就绪状态，而 run 方法只是thread的一个普通方法，还是在主线程中执行。</p><h3 id="15-wait-和-sleep-的区别？"><a href="#15-wait-和-sleep-的区别？" class="headerlink" title="15.wait()和 sleep()的区别？"></a>15.wait()和 sleep()的区别？</h3><ol><li>来自不同的类 wait():来自 Object 类； sleep():来自 Thread 类； </li><li>关于锁的释放： wait():在等待的过程中会释放锁； sleep():在等待的过程中不会释放锁 </li><li>使用的范围： wait():必须在同步代码块中使用； sleep():可以在任何地方使用； </li><li>是否需要捕获异常 wait():不需要捕获异常； sleep():需要捕获异常；</li></ol><h3 id="16-Get-和-Post-的区别？"><a href="#16-Get-和-Post-的区别？" class="headerlink" title="16.Get 和 Post 的区别？"></a>16.Get 和 Post 的区别？</h3><ol><li>Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对用户来说都是不可见的。</li><li>Get 传送的数据量较小，一般传输数据大小不超过 2k-4k（根据浏览器不同，限制不一样，但相差不大这主要是因为受 URL 长度限制；Post 传送的数据量较大，一般被默认为不受限制。 </li><li>Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个ISO10646字符集。 </li><li>Get 执行效率却比 Post 方法好。Get 是 form 提交的默认方法。</li></ol><h3 id="17-数据库事务特性"><a href="#17-数据库事务特性" class="headerlink" title="17.数据库事务特性"></a>17.数据库事务特性</h3><p>原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p><p>一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态</p><p>隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p><p>持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p><h3 id="18-隔离级别"><a href="#18-隔离级别" class="headerlink" title="18.隔离级别"></a>18.隔离级别</h3><p>（1）读未提交（read Uncommited）: 在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项目中基本不怎么用， 安全性太差； </p><p>(2) 读已提交（read commited）: 这是大多数数据库默认的隔离级别，但是不是 MySQL 的默认隔离级别；这个隔离级别满足了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题；由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等问题（下面详细介绍这种问题，结合问题来理解隔离级别的含义）；</p><p>(3 ) 可重复读（Repeatable read）： 这是 MySQL 的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （PhantomRead）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p><p>(4) 可串行化（serializable）： 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一般为了提升程序的吞吐量不会采用这个；</p><h3 id="19-你知道的-Spring-的通知类型有哪些-分别在什么时候执行"><a href="#19-你知道的-Spring-的通知类型有哪些-分别在什么时候执行" class="headerlink" title="19.你知道的 Spring 的通知类型有哪些,分别在什么时候执行?"></a>19.你知道的 Spring 的通知类型有哪些,分别在什么时候执行?</h3><p>Spring 的通知类型有四种，分别为： </p><p>​前置通知[]before]：在切点运行之前执行 </p><p>​后置通知[after-returning]：在切点正常结束之后执行 </p><p>​异常通知[after-throwing]：在切点发生异常的时候执行 </p><p>​最终通知[after]：在切点的最终执行 Spring 还有一种特殊的通知,叫做环绕通知 环绕通知运行程序员以编码的方式自己定义通知的位置, 用于解决其他通知时序问题</p><h3 id="20-Redis-给缓存数据设置过期时间有啥用？"><a href="#20-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="20.Redis 给缓存数据设置过期时间有啥用？"></a>20.Redis 给缓存数据设置过期时间有啥用？</h3><p>​因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。 过期时间除了有助于缓解内存的消耗，还有什么其他用么？ 很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。 如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多</p><h3 id="21-过期的数据的删除策略"><a href="#21-过期的数据的删除策略" class="headerlink" title="21.过期的数据的删除策略"></a>21.过期的数据的删除策略</h3><p>​如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？ 常用的过期数据的删除策略就两个 1、惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 2、定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来 减少删除操作对 CPU 时间的影响。 定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性&#x2F;懒 懒汉式删</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现自增ID</title>
    <link href="/2024/02/08/Redis%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%A2%9EID/"/>
    <url>/2024/02/08/Redis%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%A2%9EID/</url>
    
    <content type="html"><![CDATA[<h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a>全局唯一ID生成策略</h3><p><strong>·UUID</strong></p><p><strong>·Redis自增</strong></p><p><strong>·snowflake算法</strong></p><p><strong>·数据库自增</strong></p><h3 id="Redis-自增-ID-策略"><a href="#Redis-自增-ID-策略" class="headerlink" title="Redis 自增 ID 策略"></a>Redis 自增 ID 策略</h3><p class="note note-success"> 1. 每天一个key，方便统计订单量</p><p class="note note-success"> 2. ID构造是 <b>时间戳</b> + <b>计数器</b></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">//开始时间戳</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br><br>    <span class="hljs-comment">//序列号的位数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">newSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> newSecond - BEGIN_TIMESTAMP;<br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个500个线程池，然后创建一个任务，每一个任务来就执行100次，总共提交300次，测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisIdWorker redisIdWorker;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">500</span>);<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testIdWorker</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);<br>        &#125;<br>        latch.countDown();<br>    &#125;;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br>        es.submit(task);<br>    &#125;<br>    latch.await();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + (end - begin));<br>&#125;<br></code></pre></td></tr></table></figure><p>执行之后查看Redis，ID自增长到30000</p><img src="/2024/02/08/Redis%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%A2%9EID/s1.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唯一ID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux配置Neo4j</title>
    <link href="/2024/02/07/Linux%E9%85%8D%E7%BD%AENeo4j/"/>
    <url>/2024/02/07/Linux%E9%85%8D%E7%BD%AENeo4j/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Docker-镜像准备"><a href="#1-Docker-镜像准备" class="headerlink" title="1.Docker 镜像准备"></a>1.Docker 镜像准备</h3><p>我安装的是 <strong>3.5.5</strong>版本的，所以就是 ：docker pull neo4j:3.5.5</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">//寻找镜像<br>docker search neo4j<br><br>//拉取镜像<br>docker pull neo4j(:版本号) //缺省 “:版本号” 时默认安装latest版本的<br><br>//查看镜像<br>docker images<br></code></pre></td></tr></table></figure><h3 id="2、启动配置修改"><a href="#2、启动配置修改" class="headerlink" title="2、启动配置修改"></a>2、启动配置修改</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d --name container_name \  //-d表示容器后台运行 --name指定容器名字</span><br>    -p <span class="hljs-number">7474</span>:<span class="hljs-number">7474</span> -p <span class="hljs-number">7687</span>:<span class="hljs-number">7687</span> \  //映射容器的端口号到宿主机的端口号<br>    -v /home/neo4j/data:/data \  //把容器内的数据目录挂载到宿主机的对应目录下<br>    -v /home/neo4j/logs:/logs \  //挂载日志目录<br>    -v /home/neo4j/conf:/var/lib/neo4j/conf   //挂载配置目录<br>    -v /home/neo4j/import:/var/lib/neo4j/import \  //挂载数据导入目录<br>    --<span class="hljs-keyword">env</span> NEO4J_AUTH=neo4j/password \  //设定数据库的名字的访问密码<br>    neo4j:<span class="hljs-number">4.2</span>.<span class="hljs-number">2</span> //指定使用的镜像 及版本号  默认laster<br></code></pre></td></tr></table></figure><p>我的运行命令是：NEO4J_AUTH是可以指定的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">docker run -d --name neo4j -p <span class="hljs-number">7474</span>:<span class="hljs-number">7474</span> -p <span class="hljs-number">7687</span>:<span class="hljs-number">7687</span> -v /opt/elastdocker-<span class="hljs-number">1.19</span><span class="hljs-number">.0</span>/elasticsearch/<span class="hljs-keyword">data</span>/neo4j/<span class="hljs-keyword">data</span>:/<span class="hljs-keyword">data</span> -v /opt/elastdocker-<span class="hljs-number">1.19</span><span class="hljs-number">.0</span>/elasticsearch/<span class="hljs-keyword">data</span>/neo4j/logs:/logs -v /opt/elastdocker-<span class="hljs-number">1.19</span><span class="hljs-number">.0</span>/elasticsearch/<span class="hljs-keyword">data</span>/neo4j/conf:/<span class="hljs-keyword">var</span>/lib/neo4j/conf -v /opt/elastdocker-<span class="hljs-number">1.19</span><span class="hljs-number">.0</span>/elasticsearch/<span class="hljs-keyword">data</span>/neo4j/<span class="hljs-keyword">import</span>:/<span class="hljs-keyword">var</span>/lib/neo4j/<span class="hljs-keyword">import</span> --env NEO4J_AUTH=neo4j/<span class="hljs-number">200381</span> neo4j<br></code></pre></td></tr></table></figure><h3 id="3-查看是否成功运行"><a href="#3-查看是否成功运行" class="headerlink" title="3.查看是否成功运行"></a>3.查看是否成功运行</h3><p><strong>输入：</strong>docker ps 查看以运行的容器</p><img src="/2024/02/07/Linux%E9%85%8D%E7%BD%AENeo4j/s1.jpg" class=""><h3 id="4-浏览器查看"><a href="#4-浏览器查看" class="headerlink" title="4.浏览器查看"></a>4.浏览器查看</h3><p><a href="http://ip:7474/browser/">http://IP:7474/browser/</a></p><img src="/2024/02/07/Linux%E9%85%8D%E7%BD%AENeo4j/s2.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Neo4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑马点评</title>
    <link href="/2024/02/03/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/"/>
    <url>/2024/02/03/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>在学习黑马的 Reids 时，P37 留了一个课后作业，不过应该写在 service 层里面而不是写在 controller 层里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/shop-type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopTypeController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IShopTypeService typeService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryTypeList</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_TYPE_KEY;<br>        <span class="hljs-comment">// 1.查询redis缓存</span><br>        List&lt;String&gt; typeJson = stringRedisTemplate.opsForList().range(key, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 2.判断是否命中</span><br>        <span class="hljs-keyword">if</span> (CollectionUtil.isNotEmpty(typeJson)) &#123;<br>            <span class="hljs-comment">// 2.0 如果为空对象(防止缓存穿透时存入的空对象)</span><br>            <span class="hljs-keyword">if</span> (StrUtil.isBlank(typeJson.get(<span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品分类信息为空！&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 2.1 命中则转换List&lt;String&gt; -&gt; List&lt;ShopType&gt; 并返回、</span><br>            List&lt;ShopType&gt; typeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (String jsonString : typeJson) &#123;<br>                <span class="hljs-type">ShopType</span> <span class="hljs-variable">shopType</span> <span class="hljs-operator">=</span> JSONUtil.toBean(jsonString, ShopType.class);<br>                typeList.add(shopType);<br>            &#125;<br>            <span class="hljs-keyword">return</span> Result.ok(typeList);<br>        &#125;<br>        <span class="hljs-comment">// 3. 未命中，查询数据库</span><br>        List&lt;ShopType&gt; typeList = typeService.query().orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>).list();<br>        <span class="hljs-comment">// 3.1 数据库中不存在</span><br>        <span class="hljs-keyword">if</span> (CollectionUtil.isEmpty(typeList)) &#123;<br>            <span class="hljs-comment">// 添加空对象到redis，解决缓存穿透</span><br>            stringRedisTemplate.opsForList().rightPushAll(key, CollectionUtil.newArrayList(<span class="hljs-string">&quot;&quot;</span>));<br>            stringRedisTemplate.expire(key, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回错误</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;商品分类信息为空！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.2 数据库中存在,转换List&lt;ShopType&gt; -&gt; List&lt;String&gt; 类型</span><br>        List&lt;String&gt; shopTypeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (ShopType shopType : typeList) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">jsonStr</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(shopType);<br>            shopTypeList.add(jsonStr);<br>        &#125;<br>        <span class="hljs-comment">// 4.写入redis缓存, 有顺序只能RPUSH</span><br>        stringRedisTemplate.opsForList().rightPushAll(key, shopTypeList);<br>        <span class="hljs-comment">// 5. 返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(typeList);<br><br><span class="hljs-comment">//        List&lt;ShopType&gt; typeList = typeService</span><br><span class="hljs-comment">//                .query().orderByAsc(&quot;sort&quot;).list();</span><br><span class="hljs-comment">//        return Result.ok(typeList);</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑马点评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2024/01/29/Boot%E6%95%B4%E5%90%88Redis%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/01/29/Boot%E6%95%B4%E5%90%88Redis%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>​<img src="/2024/01/29/Boot%E6%95%B4%E5%90%88Redis%E6%90%AD%E5%BB%BA/downloaded_image.jpg" class=""></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
